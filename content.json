[{"title":"ReactiveCocoa之进阶","date":"2018-03-23T06:47:28.000Z","path":"2018/03/23/ReactiveCocoa之进阶/","text":"1.ReactiveCocoa常见操作方法介绍。1.1 ReactiveCocoa操作须知 所有的信号（RACSignal）都可以进行操作处理，因为所有操作方法都定义在RACStream.h中，因此只要继承RACStream就有了操作处理方法。1.2 ReactiveCocoa操作思想 运用的是Hook（钩子）思想，Hook是一种用于改变API(应用程序编程接口：方法)执行结果的技术.Hook用处：截获API调用的技术。Hook原理：在每次调用一个API返回结果之前，先执行你自己的方法，改变结果的输出。1.3 ReactiveCocoa核心方法bind ReactiveCocoa操作的核心方法是bind（绑定）,而且RAC中核心开发方式，也是绑定，之前的开发方式是赋值，而用RAC开发，应该把重心放在绑定，也就是可以在创建一个对象的时候，就绑定好以后想要做的事情，而不是等赋值之后在去做事情。 列如：把数据展示到控件上，之前都是重写控件的setModel方法，用RAC就可以在一开始创建控件的时候，就绑定好数据。 在开发中很少使用bind方法，bind属于RAC中的底层方法，RAC已经封装了很多好用的其他方法，底层都是调用bind，用法比bind简单. bind方法简单介绍和使用。 // 假设想监听文本框的内容，并且在每次输出结果的时候，都在文本框的内容拼接一段文字“输出：” // 方式一:在返回结果后，拼接。 [_textField.rac_textSignal subscribeNext:^(id x) { NSLog(@&quot;输出:%@&quot;,x); }]; // 方式二:在返回结果前，拼接，使用RAC中bind方法做处理。 // bind方法参数:需要传入一个返回值是RACStreamBindBlock的block参数 // RACStreamBindBlock是一个block的类型，返回值是信号，参数（value,stop），因此参数的block返回值也是一个block。 // RACStreamBindBlock: // 参数一(value):表示接收到信号的原始值，还没做处理 // 参数二(*stop):用来控制绑定Block，如果*stop = yes,那么就会结束绑定。 // 返回值：信号，做好处理，在通过这个信号返回出去，一般使用RACReturnSignal,需要手动导入头文件RACReturnSignal.h。 // bind方法使用步骤: // 1.传入一个返回值RACStreamBindBlock的block。 // 2.描述一个RACStreamBindBlock类型的bindBlock作为block的返回值。 // 3.描述一个返回结果的信号，作为bindBlock的返回值。 // 注意：在bindBlock中做信号结果的处理。 // 底层实现: // 1.源信号调用bind,会重新创建一个绑定信号。 // 2.当绑定信号被订阅，就会调用绑定信号中的didSubscribe，生成一个bindingBlock。 // 3.当源信号有内容发出，就会把内容传递到bindingBlock处理，调用bindingBlock(value,stop) // 4.调用bindingBlock(value,stop)，会返回一个内容处理完成的信号（RACReturnSignal）。 // 5.订阅RACReturnSignal，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。 // 注意:不同订阅者，保存不同的nextBlock，看源码的时候，一定要看清楚订阅者是哪个。 // 这里需要手动导入#import &lt;ReactiveCocoa/RACReturnSignal.h&gt;，才能使用RACReturnSignal。 [[_textField.rac_textSignal bind:^RACStreamBindBlock{ // 什么时候调用: // block作用:表示绑定了一个信号. return ^RACStream *(id value, BOOL *stop){ // 什么时候调用block:当信号有新的值发出，就会来到这个block。 // block作用:做返回值的处理 // 做好处理，通过信号返回出去. return [RACReturnSignal return:[NSString stringWithFormat:@&quot;输出:%@&quot;,value]]; }; }] subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }]; 1.4ReactiveCocoa操作方法之映射(flattenMap,Map) flattenMap，Map用于把源信号内容映射成新的内容。flattenMap简单使用 // 监听文本框的内容改变，把结构重新映射成一个新值. // flattenMap作用:把源信号的内容映射成一个新的信号，信号可以是任意类型。 // flattenMap使用步骤: // 1.传入一个block，block类型是返回值RACStream，参数value // 2.参数value就是源信号的内容，拿到源信号的内容做处理 // 3.包装成RACReturnSignal信号，返回出去。 // flattenMap底层实现: // 0.flattenMap内部调用bind方法实现的,flattenMap中block的返回值，会作为bind中bindBlock的返回值。 // 1.当订阅绑定信号，就会生成bindBlock。 // 2.当源信号发送内容，就会调用bindBlock(value, *stop) // 3.调用bindBlock，内部就会调用flattenMap的block，flattenMap的block作用：就是把处理好的数据包装成信号。 // 4.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。 // 5.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。 [[_textField.rac_textSignal flattenMap:^RACStream *(id value) { // block什么时候 : 源信号发出的时候，就会调用这个block。 // block作用 : 改变源信号的内容。 // 返回值：绑定信号的内容. return [RACReturnSignal return:[NSString stringWithFormat:@&quot;输出:%@&quot;,value]]; }] subscribeNext:^(id x) { // 订阅绑定信号，每当源信号发送内容，做完处理，就会调用这个block。 NSLog(@&quot;%@&quot;,x); }]; Map简单使用: // 监听文本框的内容改变，把结构重新映射成一个新值. // Map作用:把源信号的值映射成一个新的值 // Map使用步骤: // 1.传入一个block,类型是返回对象，参数是value // 2.value就是源信号的内容，直接拿到源信号的内容做处理 // 3.把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。 // Map底层实现: // 0.Map底层其实是调用flatternMap,Map中block中的返回的值会作为flatternMap中block中的值。 // 1.当订阅绑定信号，就会生成bindBlock。 // 3.当源信号发送内容，就会调用bindBlock(value, *stop) // 4.调用bindBlock，内部就会调用flattenMap的block // 5.flattenMap的block内部会调用Map中的block，把Map中的block返回的内容包装成返回的信号。 // 5.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。 // 6.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。 [[_textField.rac_textSignal map:^id(id value) { // 当源信号发出，就会调用这个block，修改源信号的内容 // 返回值：就是处理完源信号的内容。 return [NSString stringWithFormat:@&quot;输出:%@&quot;,value]; }] subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }]; FlatternMap和Map的区别 1.FlatternMap中的Block返回信号。2.Map中的Block返回对象。3.开发中，如果信号发出的值不是信号，映射一般使用Map4.开发中，如果信号发出的值是信号，映射一般使用FlatternMap。总结：signalOfsignals用FlatternMap。 // 创建信号中的信号 RACSubject *signalOfsignals = [RACSubject subject]; RACSubject *signal = [RACSubject subject]; [[signalOfsignals flattenMap:^RACStream *(id value) { // 当signalOfsignals的signals发出信号才会调用 return value; }] subscribeNext:^(id x) { // 只有signalOfsignals的signal发出信号才会调用，因为内部订阅了bindBlock中返回的信号，也就是flattenMap返回的信号。 // 也就是flattenMap返回的信号发出内容，才会调用。 NSLog(@&quot;%@aaa&quot;,x); }]; // 信号的信号发送信号 [signalOfsignals sendNext:signal]; // 信号发送内容 [signal sendNext:@1]; 1.5 ReactiveCocoa操作方法之组合。concat:按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号。 RACSignal signalA = [RACSignal createSignal:^RACDisposable (id subscriber) { [subscriber sendNext:@1]; [subscriber sendCompleted]; return nil; }]; RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { [subscriber sendNext:@2]; return nil; }]; // 把signalA拼接到signalB后，signalA发送完成，signalB才会被激活。 RACSignal *concatSignal = [signalA concat:signalB]; // 以后只需要面对拼接信号开发。 // 订阅拼接的信号，不需要单独订阅signalA，signalB // 内部会自动订阅。 // 注意：第一个信号必须发送完成，第二个信号才会被激活 [concatSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }]; // concat底层实现: // 1.当拼接信号被订阅，就会调用拼接信号的didSubscribe // 2.didSubscribe中，会先订阅第一个源信号（signalA） // 3.会执行第一个源信号（signalA）的didSubscribe // 4.第一个源信号（signalA）didSubscribe中发送值，就会调用第一个源信号（signalA）订阅者的nextBlock,通过拼接信号的订阅者把值发送出来. // 5.第一个源信号（signalA）didSubscribe中发送完成，就会调用第一个源信号（signalA）订阅者的completedBlock,订阅第二个源信号（signalB）这时候才激活（signalB）。 // 6.订阅第二个源信号（signalB）,执行第二个源信号（signalB）的didSubscribe // 7.第二个源信号（signalA）didSubscribe中发送值,就会通过拼接信号的订阅者把值发送出来. then:用于连接两个信号，当第一个信号完成，才会连接then返回的信号。 // then:用于连接两个信号，当第一个信号完成，才会连接then返回的信号// 注意使用then，之前信号的值会被忽略掉.// 底层实现：1、先过滤掉之前的信号发出的值。2.使用concat连接then返回的信号[[[RACSignal createSignal:^RACDisposable *(id subscriber) { [subscriber sendNext:@1]; [subscriber sendCompleted]; return nil;}] then:^RACSignal { return [RACSignal createSignal:^RACDisposable (id subscriber) { [subscriber sendNext:@2]; return nil; }];}] subscribeNext:^(id x) { // 只能接收到第二个信号的值，也就是then返回信号的值 NSLog(@”%@”,x);}];merge:把多个信号合并为一个信号，任何一个信号有新值的时候就会调用 // merge:把多个信号合并成一个信号 //创建多个信号 RACSignal signalA = [RACSignal createSignal:^RACDisposable (id subscriber) { [subscriber sendNext:@1]; return nil; }]; RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { [subscriber sendNext:@2]; return nil; }]; // 合并信号,任何一个信号发送数据，都能监听到. RACSignal *mergeSignal = [signalA merge:signalB]; [mergeSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }]; // 底层实现： // 1.合并信号被订阅的时候，就会遍历所有信号，并且发出这些信号。 // 2.每发出一个信号，这个信号就会被订阅 // 3.也就是合并信号一被订阅，就会订阅里面所有的信号。 // 4.只要有一个信号被发出就会被监听。 zipWith:把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。 RACSignal signalA = [RACSignal createSignal:^RACDisposable (id subscriber) { [subscriber sendNext:@1]; return nil; }]; RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { [subscriber sendNext:@2]; return nil; }]; // 压缩信号A，信号B RACSignal *zipSignal = [signalA zipWith:signalB]; [zipSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }]; // 底层实现: // 1.定义压缩信号，内部就会自动订阅signalA，signalB // 2.每当signalA或者signalB发出信号，就会判断signalA，signalB有没有发出个信号，有就会把最近发出的信号都包装成元组发出。 combineLatest:将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。 RACSignal signalA = [RACSignal createSignal:^RACDisposable (id subscriber) { [subscriber sendNext:@1]; return nil;}]; RACSignal signalB = [RACSignal createSignal:^RACDisposable (id subscriber) { [subscriber sendNext:@2]; return nil;}]; // 把两个信号组合成一个信号,跟zip一样，没什么区别RACSignal *combineSignal = [signalA combineLatestWith:signalB]; [combineSignal subscribeNext:^(id x) { NSLog(@”%@”,x);}]; // 底层实现：// 1.当组合信号被订阅，内部会自动订阅signalA，signalB,必须两个信号都发出内容，才会被触发。// 2.并且把两个信号组合成元组发出。reduce聚合:用于信号发出的内容是元组，把信号发出元组的值聚合成一个值RACSignal signalA = [RACSignal createSignal:^RACDisposable (id subscriber) { [subscriber sendNext:@1]; return nil;}]; RACSignal signalB = [RACSignal createSignal:^RACDisposable (id subscriber) { [subscriber sendNext:@2]; return nil;}]; // 聚合// 常见的用法，（先组合在聚合）。combineLatest:(id)signals reduce:(id (^)())reduceBlock// reduce中的block简介:// reduceblcok中的参数，有多少信号组合，reduceblcok就有多少参数，每个参数就是之前信号发出的内容// reduceblcok的返回值：聚合信号之后的内容。RACSignal reduceSignal = [RACSignal combineLatest:@[signalA,signalB] reduce:^id(NSNumber num1 ,NSNumber *num2){ return [NSString stringWithFormat:@”%@ %@”,num1,num2]; }]; [reduceSignal subscribeNext:^(id x) { NSLog(@”%@”,x);}]; // 底层实现:// 1.订阅聚合信号，每次有内容发出，就会执行reduceblcok，把信号内容转换成reduceblcok返回的值。1.6 ReactiveCocoa操作方法之过滤。 filter:过滤信号，使用它可以获取满足条件的信号. // 过滤:// 每次信号发出，会先执行过滤条件判断.[_textField.rac_textSignal filter:^BOOL(NSString *value) { return value.length &gt; 3;}];ignore:忽略完某些值的信号. // 内部调用filter过滤，忽略掉ignore的值[[_textField.rac_textSignal ignore:@”1”] subscribeNext:^(id x) { NSLog(@”%@”,x);}];distinctUntilChanged:当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。 // 过滤，当上一次和当前的值不一样，就会发出内容。// 在开发中，刷新UI经常使用，只有两次数据不一样才需要刷新[[_textField.rac_textSignal distinctUntilChanged] subscribeNext:^(id x) { NSLog(@”%@”,x);}];take:从开始一共取N次的信号// 1、创建信号RACSubject *signal = [RACSubject subject]; // 2、处理信号，订阅信号[[signal take:1] subscribeNext:^(id x) { NSLog(@”%@”,x);}]; // 3.发送信号[signal sendNext:@1]; [signal sendNext:@2];takeLast:取最后N次的信号,前提条件，订阅者必须调用完成，因为只有完成，就知道总共有多少信号.// 1、创建信号RACSubject *signal = [RACSubject subject]; // 2、处理信号，订阅信号[[signal takeLast:1] subscribeNext:^(id x) { NSLog(@”%@”,x);}]; // 3.发送信号[signal sendNext:@1]; [signal sendNext:@2]; [signal sendCompleted];takeUntil:(RACSignal *):获取信号直到某个信号执行完成// 监听文本框的改变直到当前对象被销毁[_textField.rac_textSignal takeUntil:self.rac_willDeallocSignal];skip:(NSUInteger):跳过几个信号,不接受。// 表示输入第一次，不会被监听到，跳过第一次发出的信号[[_textField.rac_textSignal skip:1] subscribeNext:^(id x) { NSLog(@”%@”,x);}];switchToLatest:用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。RACSubject signalOfSignals = [RACSubject subject];RACSubject signal = [RACSubject subject]; // 获取信号中信号最近发出信号，订阅最近发出的信号。// 注意switchToLatest：只能用于信号中的信号[signalOfSignals.switchToLatest subscribeNext:^(id x) { NSLog(@”%@”,x);}];[signalOfSignals sendNext:signal];[signal sendNext:@1];1.7 ReactiveCocoa操作方法之秩序。 doNext: 执行Next之前，会先执行这个BlockdoCompleted: 执行sendCompleted之前，会先执行这个Block [[[[RACSignal createSignal:^RACDisposable *(id subscriber) { [subscriber sendNext:@1]; [subscriber sendCompleted]; return nil;}] doNext:^(id x) {// 执行[subscriber sendNext:@1];之前会调用这个Block NSLog(@”doNext”);;}] doCompleted:^{ // 执行[subscriber sendCompleted];之前会调用这个Block NSLog(@”doCompleted”);; }] subscribeNext:^(id x) { NSLog(@”%@”,x);}];1.8 ReactiveCocoa操作方法之线程。 deliverOn: 内容传递切换到制定线程中，副作用在原来线程中,把在创建信号时block中的代码称之为副作用。 subscribeOn: 内容传递和副作用都会切换到制定线程中。 1.9 ReactiveCocoa操作方法之时间。 timeout：超时，可以让一个信号在一定的时间后，自动报错。 RACSignal signal = [[RACSignal createSignal:^RACDisposable (id subscriber) { return nil;}] timeout:1 onScheduler:[RACScheduler currentScheduler]]; [signal subscribeNext:^(id x) { NSLog(@”%@”,x);} error:^(NSError *error) { // 1秒后会自动调用 NSLog(@”%@”,error);}];interval 定时：每隔一段时间发出信号 [[RACSignal interval:1 onScheduler:[RACScheduler currentScheduler]] subscribeNext:^(id x) { NSLog(@”%@”,x);}];delay 延迟发送next。 RACSignal signal = [[[RACSignal createSignal:^RACDisposable (id subscriber) { [subscriber sendNext:@1]; return nil;}] delay:2] subscribeNext:^(id x) { NSLog(@”%@”,x);}];1.9 ReactiveCocoa操作方法之重复。 retry重试 ：只要失败，就会重新执行创建信号中的block,直到成功. __block int i = 0; [[[RACSignal createSignal:^RACDisposable *(id subscriber) { if (i == 10) { [subscriber sendNext:@1]; }else{ NSLog(@&quot;接收到错误&quot;); [subscriber sendError:nil]; } i++; return nil; }] retry] subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); } error:^(NSError *error) { }]; replay重放：当一个信号被多次订阅,反复播放内容 RACSignal signal = [[RACSignal createSignal:^RACDisposable (id subscriber) { [subscriber sendNext:@1]; [subscriber sendNext:@2]; return nil; }] replay]; [signal subscribeNext:^(id x) { NSLog(@&quot;第一个订阅者%@&quot;,x); }]; [signal subscribeNext:^(id x) { NSLog(@&quot;第二个订阅者%@&quot;,x); }]; throttle节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。 RACSubject *signal = [RACSubject subject]; _signal = signal; // 节流，在一定时间（1秒）内，不接收任何信号内容，过了这个时间（1秒）获取最后发送的信号内容发出。[[signal throttle:1] subscribeNext:^(id x) { NSLog(@”%@”,x);}];2.介绍MVVM架构思想。2.1 程序为什么要架构：便于程序员开发和维护代码。 2.2 常见的架构思想: MVC M:模型 V:视图 C:控制器 MVVM M:模型 V:视图+控制器 VM:视图模型 MVCS M:模型 V:视图 C:控制器 C:服务类 VIPER V:视图 I:交互器 P:展示器 E:实体 R:路由PS:VIPER架构思想 2.3 MVVM介绍 模型(M):保存视图数据。 视图+控制器(V):展示内容 + 如何展示 视图模型(VM):处理展示的业务逻辑，包括按钮的点击，数据的请求和解析等等。 3.ReactiveCocoa + MVVM 实战一：登录界面3.1需求+分析+步骤/* 需求：1.监听两个文本框的内容，有内容才允许按钮点击 2.默认登录请求. 用MVVM：实现，之前界面的所有业务逻辑 分析：1.之前界面的所有业务逻辑都交给控制器做处理 2.在MVVM架构中把控制器的业务全部搬去VM模型，也就是每个控制器对应一个VM模型. 步骤：1.创建LoginViewModel类，处理登录界面业务逻辑. 2.这个类里面应该保存着账号的信息，创建一个账号Account模型 3.LoginViewModel应该保存着账号信息Account模型。 4.需要时刻监听Account模型中的账号和密码的改变，怎么监听？ 5.在非RAC开发中，都是习惯赋值，在RAC开发中，需要改变开发思维，由赋值转变为绑定，可以在一开始初始化的时候，就给Account模型中的属性绑定，并不需要重写set方法。 6.每次Account模型的值改变，就需要判断按钮能否点击，在VM模型中做处理，给外界提供一个能否点击按钮的信号. 7.这个登录信号需要判断Account中账号和密码是否有值，用KVO监听这两个值的改变，把他们聚合成登录信号. 8.监听按钮的点击，由VM处理，应该给VM声明一个RACCommand，专门处理登录业务逻辑. 9.执行命令，把数据包装成信号传递出去 10.监听命令中信号的数据传递 11.监听命令的执行时刻 */3.2 控制器的代码@interface ViewController () @property (nonatomic, strong) LoginViewModel *loginViewModel; @property (weak, nonatomic) IBOutlet UITextField accountField;@property (weak, nonatomic) IBOutlet UITextField pwdField; @property (weak, nonatomic) IBOutlet UIButton *loginBtn; @end (LoginViewModel *)loginViewModel{ if (_loginViewModel == nil) { _loginViewModel = [[LoginViewModel alloc] init]; } return _loginViewModel;} // 视图模型绑定 (void)bindModel{ // 给模型的属性绑定信号 // 只要账号文本框一改变，就会给account赋值 RAC(self.loginViewModel.account, account) = _accountField.rac_textSignal; RAC(self.loginViewModel.account, pwd) = _pwdField.rac_textSignal; // 绑定登录按钮 RAC(self.loginBtn,enabled) = self.loginViewModel.enableLoginSignal; // 监听登录按钮点击 [[_loginBtn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) { // 执行登录事件 [self.loginViewModel.LoginCommand execute:nil]; }];}3.3 VM的代码@interface LoginViewModel : NSObject @property (nonatomic, strong) Account *account; // 是否允许登录的信号@property (nonatomic, strong, readonly) RACSignal *enableLoginSignal; @property (nonatomic, strong, readonly) RACCommand *LoginCommand; @end @implementation LoginViewModel (Account *)account{ if (_account == nil) {_account = [[Account alloc] init]; } return _account;} (instancetype)init{ if (self = [super init]) {[self initialBind]; } return self;} // 初始化绑定 (void)initialBind{ // 监听账号的属性值改变，把他们聚合成一个信号。 _enableLoginSignal = [RACSignal combineLatest:@[RACObserve(self.account, account),RACObserve(self.account, pwd)] reduce:^id(NSString account,NSString pwd){ return @(account.length &amp;&amp; pwd.length); }]; // 处理登录业务逻辑 _LoginCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) { NSLog(@&quot;点击了登录&quot;); return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { // 模仿网络延迟 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ [subscriber sendNext:@&quot;登录成功&quot;]; // 数据传送完毕，必须调用完成，否则命令永远处于执行状态 [subscriber sendCompleted]; }); return nil; }]; }]; // 监听登录产生的数据 [_LoginCommand.executionSignals.switchToLatest subscribeNext:^(id x) { if ([x isEqualToString:@&quot;登录成功&quot;]) { NSLog(@&quot;登录成功&quot;); } }]; // 监听登录状态 [[_LoginCommand.executing skip:1] subscribeNext:^(id x) { if ([x isEqualToNumber:@(YES)]) { // 正在登录ing... // 用蒙版提示 [MBProgressHUD showMessage:@&quot;正在登录...&quot;]; }else { // 登录成功 // 隐藏蒙版 [MBProgressHUD hideHUD]; } }]; }4.ReactiveCocoa + MVVM 实战二：网络请求数据4.1 接口：这里先给朋友介绍一个免费的网络数据接口，豆瓣。可以经常用来练习一些网络请求的小Demo. 4.2 需求+分析+步骤 /* 需求：请求豆瓣图书信息，url:https://api.douban.com/v2/book/search?q=基础 分析：请求一样，交给VM模型管理 步骤: 1.控制器提供一个视图模型（requesViewModel），处理界面的业务逻辑 2.VM提供一个命令，处理请求业务逻辑 3.在创建命令的block中，会把请求包装成一个信号，等请求成功的时候，就会把数据传递出去。 4.请求数据成功，应该把字典转换成模型，保存到视图模型中，控制器想用就直接从视图模型中获取。 5.假设控制器想展示内容到tableView，直接让视图模型成为tableView的数据源，把所有的业务逻辑交给视图模型去做，这样控制器的代码就非常少了。 */4.3控制器代码@interface ViewController () @property (nonatomic, weak) UITableView *tableView; @property (nonatomic, strong) RequestViewModel *requesViewModel; @end @implementation ViewController (RequestViewModel *)requesViewModel{ if (_requesViewModel == nil) { _requesViewModel = [[RequestViewModel alloc] init]; } return _requesViewModel;} (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 创建tableView UITableView *tableView = [[UITableView alloc] initWithFrame:self.view.bounds]; tableView.dataSource = self.requesViewModel; [self.view addSubview:tableView]; // 执行请求RACSignal *requesSiganl = [self.requesViewModel.reuqesCommand execute:nil]; // 获取请求的数据 [requesSiganl subscribeNext:^(NSArray *x) { self.requesViewModel.models = x; [self.tableView reloadData]; }]; } @end4.4视图模型(VM)代码@interface RequestViewModel : NSObject // 请求命令 @property (nonatomic, strong, readonly) RACCommand *reuqesCommand; //模型数组 @property (nonatomic, strong, readonly) NSArray *models; @end @implementation RequestViewModel (instancetype)init{ if (self = [super init]) { [self initialBind]; } return self;} (void)initialBind{ _reuqesCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) { RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@&quot;q&quot;] = @&quot;基础&quot;; // 发送请求 [[AFHTTPRequestOperationManager manager] GET:@&quot;https://api.douban.com/v2/book/search&quot; parameters:parameters success:^(AFHTTPRequestOperation * _Nonnull operation, id _Nonnull responseObject) { NSLog(@&quot;%@&quot;,responseObject); // 请求成功调用 // 把数据用信号传递出去 [subscriber sendNext:responseObject]; [subscriber sendCompleted]; } failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) { // 请求失败调用 }]; return nil; }]; // 在返回数据信号时，把数据中的字典映射成模型信号，传递出去 return [requestSignal map:^id(NSDictionary *value) { NSMutableArray *dictArr = value[@&quot;books&quot;]; // 字典转模型，遍历字典中的所有元素，全部映射成模型，并且生成数组 NSArray *modelArr = [[dictArr.rac_sequence map:^id(id value) { return [Book bookWithDict:value]; }] array]; return modelArr; }]; }]; } #pragma mark - UITableViewDataSource (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{ return self.models.count;} (UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath )indexPath{ static NSString ID = @”cell”; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; if (cell == nil) { cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID]; } Book *book = self.models[indexPath.row]; cell.detailTextLabel.text = book.subtitle; cell.textLabel.text = book.title; return cell;} @end","tags":[{"name":"RAC","slug":"RAC","permalink":"http://jokersnow.com/tags/RAC/"}]},{"title":"MVVM与RAC","date":"2017-07-08T01:43:19.000Z","path":"2017/07/08/MMVM与RAC/","text":"MVC任何一个正经开发过一阵子软件的人都熟悉MVC. 它意思是Model View Controller, 是一个在复杂应用设计中组织代码的公认模式. 它也被证实在 iOS 开发中有着第二种含义: Massive View Controller(重量级视图控制器). 它让许多程序员绞尽脑汁如何去使代码被解耦和组织地让人满意. 总的来说, ios 开发者已经得出结论: 他们需要给视图控制器瘦身, 并进一步分离事物;但该怎么做呢? MVVM于是MVVM流行起来, 它代表Model View View-Model, 它在这帮助我们创建更易处理, 更佳设计的代码.有时候违背苹果建议的编码方式并不是个好做法. 我不是说不赞成这样子, 我指的是可能会弊大于利. 比如我不建议你去实现个自己的 view controller 基类并试着自己处理视图生命周期. 带着这种情绪, 我想提个问题: 使用除苹果推荐的 MVC 之外的应用设计模式是愚蠢的么? 不. 有两个原因. 苹果没有为解决重量级试图控制器问题提供真正的指导. 他们留给我们来解决如何向代码添加更多清晰的思路. 用 MVVM 来实现这个目的想必是极好哒. (在今年 WWDC 的一些视频中, 苹果工程师在屏幕上的示例代码的确少许出现了 view-model, 不知道是否因为有它才成为了示例代码)MVVM, 至少是我将要在这里展示的 MVVM 的风格, 都跟 MVC 十分兼容. 仿佛我们将 MVC 进行到下一个逻辑步骤.我不会提及 MVC/MVVM 的历史, 因为其他地方已经有所介绍, 并且我也不精通. 我将会关注如何用它进行 iOS/Mac 开发. 定义 MVVMModel - model 在 MVVM 中没有真正的变化. 取决于你的偏好, 你的 model 可能会或可能不会封装一些额外的业务逻辑工作. 我更倾向于把它当做一个容纳表现数据-模型对象信息的结构体, 并在一个单独的管理类中维护的创建/管理模型的统一逻辑.View - view 包含实际 UI 本身(不论是 UIView 代码, storyboard 和 xib), 任何视图特定的逻辑, 和对用户输入的反馈. 在 iOS 中这不仅需要 UIView 代码和那些文件, 还包括很多需由 UIViewController 处理的工作.View-Model - 这个术语本身会带来困惑, 因为它混搭了两个我们已知的术语, 但却是完全不同的东东. 它不是传统数据-模型结构中模型的意思(又来了, 只是我喜欢这个例子). 它的职责之一就是作为一个表现视图显示自身所需数据的静态模型;但它也有收集, 解释和转换那些数据的责任. 这留给了 view (controller) 一个更加清晰明确的任务: 呈现由 view-model 提供的数据.关于 view-model 的更多内容view-model 一词的确不能充分表达我们的意图. 一个更好的术语可能是 “View Coordinator”(感谢Dave Lee提的这个 “View Coordinator” 术语, 真是个好点子). 你可以认为它就像是电视新闻主播背后的研究人员和作家团队. 它从必要的资源(数据库, 网络服务调用, 等)中获取原始数据, 运用逻辑, 并处理成 view (controller) 的展示数据. 它(通常通过属性)暴露给视图控制器需要知道的仅关于显示视图工作的信息(理想地你不会暴漏你的 data-model 对象). 它还负责对上游数据的修改(比如更新模型/数据库, API POST 调用). MVC 世界中的 MVVM我认为 MVVM 这个首字母缩写如同 view-model 术语一样, 对如何使用它们进行 iOS 开发体现得有点不太准确. 让我们再检查下这个首字母缩写, 了解下它是怎么与 MVC 融为一体的. 为了图解表示, 我们颠倒了 MVC 中的 V 和 C, 于是首字母缩写更能准确地反映出组件间的关系方位, 给我们带来 MCV. 我也会对 MVVM 这么干, 将 V(iew) 移到 VM 的右边最终成为了 MVMV. (我相信这些首字母缩写起初不排成这样更合理的顺序是有原因的. ) 这是这两种模式如何在 iOS 中组装在一起的简单映射: 我试图遵循区块尺寸(非常)大致对应它们负责的工作量.注意到视图控制器有多大?你可以看到我们巨大的视图控制器和 view-model 之间有大块工作上的重合.你也可以看看视图控制器在 MVVM 中的足迹有多大一部分是跟视图重合的.你大可安心获知我们并没有真的去除视图控制器的概念或抛弃 “controller” 术语来匹配 MVVM. (唷. )我们正要将重合的那块工作剥离到 view-model 中, 并让视图控制器的生活更加简单. 我们实际上最终以 MVMCV 告终. Model View-Model Controller View. 我确信我无拘无束的应用设计模式骇客行为会让人大吃一惊. 我们的结果: 现在视图控制器仅关注于用 view-model 的数据配置和管理各种各样的视图, 并在先关用户输入时让 view-model 获知并需要向上游修改数据. 视图控制器不需要了解关于网络服务调用, Core Data, 模型对象等. (事实上有时通过 view-model 头文件而不是复制一大堆属性来暴漏 model 是很务实的, 后面还会有) view-model 会在视图控制器上以一个属性的方式存在. 视图控制器知道 view-model 和它的公有属性, 但是 view-model 对视图控制器一无所知. 你早就该对这个设计感觉好多了因为我们的关注点在这儿进行更好地分离. 帮助你理解我们如何把组件组装在一起还有组件对应职责的另一种方式, 就是着眼于我们新的应用构建模块层级图. (感谢Dave Lee @kastiglione) View-Model 和 View Controller, 在一起，但独立我们来看个简单的 view-model 头文件来对我们新构件的长相有个更好地概念. 为了情节简单, 我们构建按了一个伪造的推特客户端来查看任何推特用户的最新回复, 通过输入他们的姓名并点击 “Go”. 我们的样例界面将会是这样: 有一个让用户输入他们姓名的 UITextField , 和一个写着 “Go” 的 UIButton有显示被查看的当前用户头像和姓名的 UIImageView 和 UILabel 各一个下面放着一个显示最新回复推文的 UITableView允许无限滚动 View-Model 实例我们的 view-model 头文件应该长这样: ///MYTwitterLookupViewModel.h @interface MYTwitterLookupViewModel: NSObject @property (nonatomic, assign, readonly, getter=isUsernameValid) BOOL usernameValid; @property (nonatomic, strong, readonly) NSString *userFullName; @property (nonatomic, strong, readonly) UIImage *userAvatarImage; @property (nonatomic, strong, readonly) NSArray *tweets; @property (nonatomic, assign, readonly) BOOL allTweetsLoaded; @property (nonatomic, strong, readwrite) NSString *username; - (void) getTweetsForCurrentUsername; - (void) loadMoreTweets; 相当直截了当的填充. 注意到这些壮丽的 readonly 属性了么?这个 view-model 暴漏了视图控制器所必需的最小量信息, 视图控制器实际上并不在乎 view-model 是如何获得这些信息的. 现在我们两者都不在乎. 仅仅假定你习惯于标准的网络服务请求, 校验, 数据操作和存储. view-model 不做的事儿对视图控制器以任何形式直接起作用或直接通告其变化View Controller(视图控制器)视图控制器从 view-model 获取的数据将用来: 当 usernameValid 的值发生变化时触发 “Go” 按钮的 enabled 属性 当 usernameValid 等于 NO 时调整按钮的 alpha 值为0. 5(等于 YES 时设为1. 0) 更新 UILable 的 text 属性为字符串 userFullName 的值 更新 UIImageView 的 image 属性为 userAvatarImage 的值 用 tweets 数组中的对象设置表格视图中的 cell (后面会提到) 当滑到表格视图底部时如果 allTweetsLoaded 为 NO, 提供一个 显示 “loading” 的 cell视图控制器将对 view-model 起如下作用: 每当 UITextField 中的文本发生变化, 更新 view-model 上仅有的 readwrite 属性 username 当 “Go” 按钮被按下时调用 view-model 上的 getTweetsForCurrentUsername 方法 当到达表格中的 “loading” cell 时调用 view-model 上的 loadMoreTweets 方法视图控制器不做的事儿: 发起网络服务调用 管理 tweets 数组 判定 username 内容是否有效 将用户的姓和名格式化为全名 下载用户头像并转成 UIImage(如果你习惯在 UIImageView 上使用类别从网络加载图片, 你可以暴漏 URL 而不是图片. 这样就给 view-model 与 UIKit 之间一个更清晰的划分, 但我视 UIImage 为数据而非数据的确切显示. 这些东西不是固定死的. ) 流汗请再次注意视图控制器总的责任是处理 view-model 中的变化. 子 View-Model我提到过使用 view-model 上的 tweets 数组中的对象配置表格视图的 cell.通常你会期待展现 tweets 的是数据-模型对象. 你可能已经对其感到奇怪, 因为我们试图通过 MVVM 模式不暴漏数据-模型对象. (前面提到过的) view-model 不必在屏幕上显示所有东西. 你可用子 view-model 来代表屏幕上更小, 更潜在被封装的部分. 如果一个视图上的一小块儿(比如表格的 cell)在 app 中可以被重用以及(或)表现多个数据-模型对象, 子 view-model 会格外有利. 你不总是需要子 view-model. 比如, 我可能用表格 header 视图来渲染我们“tweetboat plus”应用的顶部. 它不是个可重用的组件, 所以我可能仅是将我们已经给视图控制器用过的相同的 view-model 传给那个自定义的 header 视图. 它会用到 view-model 中它需要的信息, 而无视余下的部分. 这对于保持子视图同步是极好的方式, 因为它们可以有效地与信息中相同确切的上下文作用, 并观察确切相同属性的更新. 在我们的例子中, tweets 数组将会被下面这样的子 view-model 充满: ///MyTweetCellViewModel.h @interface MYTweetCellViewModel: NSObject @property (nonatomic, strong, readonly) NSString *tweetAuthorFullName; @property (nonatomic, strong, readonly) UIImage *tweetAuthorAvatarImage; @property (nonatomic, strong, readonly) NSString *tweetContent; 你可能认为这也太像普通”推特”里的数据-模型对象了吧. 为啥要干将其转化成 view-model 的工作?即使类似, view-model 让我们限制信息只暴露给我们需要的地方, 提供额外数据转换的属性, 或为特定的视图计算数据. (此外, 当可以不暴露可变数据-模型对象时也是极好的, 因为我们希望 view-model 自己承担起更新它们的任务, 而不是靠视图或视图控制器. ) View-Model 从哪来?那么 view-model 是何时何处被创建的呢?视图控制器创建它们自己的 view-model 么? View-Model 产生 View-Model严格来说, 你应该为 app delegate 中的顶级视图控制器创建一个 view-model. 当展示一个新的视图控制器时, 或很小的视图被 view-model 表现时, 你应要求当前的 view-model 为你创建一个子 view-model. 加入我们想要在用户轻拍应用顶部的头像时添加一个资料视图控制器. 我们可以为一级 view-model 添加类似如下方法: - (MYTwitterUserProfileViewModel *) viewModelForCurrentUser; 然后在我们的一级视图控制器中这么用它: //MYMainViewController.m - (IBAction) didTapPrimaryUserAvatar { MYTwitterUserProfileViewModel *userProfileViewModel = [self.viewModel viewModelForCurrentUser]; MYTwitterUserProfileViewController *profileViewController = [[MYTwitterUserProfileViewController alloc] initWithViewModel: userProfileViewModel]; [self.navigationController pushViewController: profileViewController animated:YES]; } 在这个例子中我将会展现当前用户的资料视图控制器, 但是我的资料视图控制器需要一个 view-model. 我这的主视图控制器不知道(也不该知道)用于创建关联相关用户 view-model 的全部必要数据, 所以它请求它自己的 view-model 来干这种创建新 view-model 的苦差事. View-Model 列表至于我们的推特 cell, 当数据驱动屏幕(在这个例子中或许是通过网络服务调用)聚到一起时, 我将会代表性地提前为对应的 cell 创建所有的 view-model. 所以在我们这个方案中, tweets 将会是一个 MYTweetCellViewModel 对象数组. 在我的表格视图中的 cellForRowAtIndexPath 方法中, 我将会在正确的索引上简单地抓取 view-model, 并把它赋值给我的 cell 上的 view-model 属性. Functional Core, Imperative Shellview-model 这种通往应用设计的方法是一块应用设计之路上的垫脚石, 这种被称作“Functional Core, Imperative Shell”的应用设计由Gary Bernhardt创造. (我最近十分有幸去听Andy Matuschak关于这方面的演讲, 他为”胖的数值层, 瘦的对象层”提出充分理由. 虽然观点相似, 但关注于我们怎样移除对象和它们状态的边界影响性质, 并用 Swift 中的新数据结构构建更加函数式, 可测试的数值层. ) Functional Coreview-model 就是 “functional core”, 尽管实际上在 iOS/Objective-C 中达到纯函数水平是很棘手的(swift 提供了一些附加的函数性, 这会让我们更接近). 大意是让我们的 view-model 尽可能少的对剩余的”应用世界”的依赖和影响. 那意味着什么?想起你第一次学编程时可能学到的简单函数吧. 它们可能接受一两个参数并输出一个结果. 数据输入, 数据输出.这个函数可能是做一些数学运算或是将姓和名结合到一起. 无论应用的其他地方发生啥, 这个函数总是对相同的输入产生相同的输出. 这就是函数式方面. 这就是我们为 view-model 谋求的东西. 他们富有逻辑和转换数据并将结果存到属性的功能. 理想上相同的输入(比如网络服务响应)将会导出相同的输出(属性的值). 这意味着尽可能多地消除由”应用世界”剩余部分带来的可能影响输出的因素, 比如使用一堆状态. 一个好的第一步就是不要再 view-model 头文件中引入 UIKit.h.(这是个重大原则, 但也有些灰色区域. 比如, 你可能认为 UIImage 是数据而不是展示信息. PS: 我爱这么干. 既然这样的话就得引入 UIKit. h 以便使用 UIImage 类)UIKit 其性质就是将要影响许多应用世界. 它包含很多”副作用”, 凭借改变一个值或调用一个函数将触发很多间接(甚至未知)的改变. 更新: 刚刚看了 Andy 在函数式 Swift 会议上给出的另一个超赞的演讲, 于是又想到了一些. 要清楚你的 view-model 仍然只是一个对象, 而不用维护一些状态(否则它将不会是你视图中非常好用的模型了. )但你仍该努力将尽可能多的逻辑移到无状态的函数”值”中. 再重复一次, Swift在这方面比 objective-c 更加可行. Imperative (Declarative?) Shell命令式外壳 (Imperative Shell) 是我们需要做所有的状态转换, 应用世界改变的苦差事的地方, 为的是将 view-model 数据转成给用户在屏幕上看到的东西. 这是我们的视图(控制器), 实际上我们在这分离 UIKit 的工作. 我仍将特别注意尽可能消除状态并用 ReactiveCocoa 这种陈述性质的东西做这方面工作, 而 iOS 和 UIKit 在设计上是命令式的. (表格的 data source 就是个很好的例子, 因为它的委托模式强制将状态应用到委托中, 为了当请求发生时能够为表格视图提供信息. 实际上委托模式通常强制一大堆状态的使用) 可测试的核心iOS 的单元测试是个脏, 苦, 乱的活儿. 至少我去做的时候得出的是这么个结论. 就这方面我还出读过一两本书, 但当开始做视图控制器的 mocking 和 swizzling 使其一些逻辑可测试时, 我目光呆滞. 我最终把单元测试归入模型和任何同类别模型管理类中. (译者注: mock 是测试常用的手段, 而 method swizzling 是基于 Objective-C Runtime 交换方法实现的黑魔法) 这个函数式核心一样的 view-model 的最大优点, 除了 bug 数量随着状态数递减之外, 就是变得非常能够进行单元测试. 如果你有那种每次输入相同而产生的输出也相同的方法, 那就非常适合单元测试的世界. 我们现在将我们的数据用获取/逻辑/转换提取出, 避免了视图控制器的复杂性. 那意味着构建棒棒哒测试时不需要用疯狂的 mock 对象, method swizzling, 或其他疯癫的变通方法(希望能有). 连接一切那么当 view-model 的共有属性发生变化时我们如何更新我们的视图呢? 绝大部分时间我们用对应的 view-model 来初始化视图控制器, 有点类似我们刚刚在上文见到的: MYTwitterUserProfileViewController *profileViewController = [[MYTwitterUserProfileViewController alloc] initWithViewModel: userProfileViewModel]; 有时你无法在初始化时将 view-model 传入, 比如在 storyboard segue 或 cell dequeuing 的情况下. 这时你应该在讨论中的视图(控制器)中暴露一个公有可写的 view-model 属性. MYTwitterUserCell *cell = [self.tableView dequeueReusableCellWithIdentifier: @&quot;MYTwitterUserCell&quot; forIndexPath: indexPath]; // grab the cell view-model from the vc view-model and assign it cell.viewModel = self.viewModel. tweets[indexPath. row]; 有时我们可以在钩子程序调用前传入 view-model, 比如 init 和 viewDidLoad, 我们可以从view-model 的属性初始化所有 UI 元素的状态. ///dontDoThis1.m - (id) initWithViewModel:(MYTwitterLookupViewModel *) viewModel { self = [super init]; if (!self) return nil; _viewModel = viewModel; return self; } - (void) viewDidLoad { [super viewDidLoad]; _goButton.enabled = viewModel.isUsernameValid; _goButton.alpha = viewModel.isUsernameValid ? 1 : 0.5; // etc } 好棒!我们已经配置好了初始值. 当 view-model 上的数据改变时怎么办? 当”go” 按钮在什么时候可用了怎么办?当用户标签和头像在什么时候从网络上下载并填充了怎么办? 我们可以将视图控制器暴露给 view-model, 以便于当相关数据变化或类似事件发送时它可以调用一个 “updateUI” 方法. (别这么干. )在 view-model 上将视图控制器作为一个委托?当 view-model 内容有变化时发个通知?(不不不不. ) 我们的视图控制器会感知一些变化的发生. 我们可以使用从 UITextfield 得来的委托方法在每当有字符变化时通过检查 view-model 来更新按钮的状态. ///dontDoThisEither.m - (void)textFieldDidChange:(UITextField *)sender { /// update the view-model self.viewModel.username = sender.text; /// check if things are now valid self.goButton.enabled = self.viewModel.isUsernameValid; self.goButton.alpha = self.viewModel.isUsernameValid ? 1.0 : 0.5; } 这种方法解决的场景是在只有再文本框发生变化时才会影响 view-model 中的 isUsernameValid 值. 假使还有其他变量/动作改变 isUsernameValid 的状态将会怎么样?对于 view-model 中的网络调用会怎么样?或许我们该为 view-model 上的方法加一个完成后回调处理, 这样我们此时就可以更新 UI 的一切东西了?使用珍贵而笨重的 KVO 方法怎么样? 我们或许最终使用多种多样我们熟悉的机制将 view-model 和视图控制器所有的接触点都连起来, 但你已经知道了标题上不是这么写的. 这样在代码中创建了大量的入口点, 仅仅为了简单的更新 UI 就要在代码中完全重新创建应用状态上下文. 进入 ReactiveCocoaReactiveCocoa(RAC) 是来拯救我们的, 并恰好返回给我们一点理智. 让我们看看如何做到. 思考在一个新的用户页面上控制信息的流动, 当表单合法时更新提交按钮的状态. 你现在可能会照下面这么做: 你最后通过使用状态, 小心翼翼地代码中许多不同且零碎无关的内容穿到简单的逻辑上. 看看你信息流中所有不同的入口点?(这还只是一个 UI 元素中的一条逻辑线. )我们程序中现在用的抽象概念还不够厉害, 不能为我们追踪所有事物的关系, 所以我们停止自己去干这蛋疼事儿. 让我们看看陈述版本: 这看起来可能像是为我们应用流程文档中的一张老旧的计算机科学图解. 通过陈述式的编程, 我们使用了更高层次的抽象, 来让我们实际编程更靠近我们在脑海中设计流程的方式. 我们让电脑为我们做更多工作. 实际的代码更加像这幅图了. RACSignalRACSignal (信号)就 RAC 来说是构造单元. 它代表我们最终将要收到的信息. 当你能将未来某时刻收到的消息具体表示出来时, 你可以开始预先(陈述性)运用逻辑并构建你的信息流,而不是必须等到事件发生(命令式). 信号会为了控制通过应用的信息流而获得所有这些异步方法(委托, 回调 block, 通知, KVO, target/action 事件观察, 等)并将它们统一到一个接口下.这只是直观理解. 不仅是这些, 因为信息会流过你的应用, 它还提供给你轻松转换/分解/合并/过滤信息的能力. 那么什么是信号呢?这是一个信号: 信号是一个发送一连串值的物体. 但是我们这儿的信号啥也不干, 因为它还没有订阅者. 如果有订阅者监听时(已订阅)信号才会发信息. 它将会向那个订阅者发送0或多个载有数值的”next”事件, 后面跟着一个”complete”事件或一个”error”事件. (信号类似于其他语言/工具包中的 “promise”, 但更强大, 因为它不仅限于向它的订阅者一次只传递一个返回值. ) 正如我之前提到的, 如果觉得需要的话你可以过滤, 转换, 分解和合并那些值. 不同的订阅者可能需要使用信号通过不同方式发送的值. 信号发送的值是从哪获得的?信号是一些等待某事发生的异步代码, 然后把结果值发送给它们的订阅者. 你可以用 RACSignal 的类方法 createSignal:手动创建信号: ///networkSignal.m RACSignal *networkSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { NetworkOperation *operation = [NetworkOperation getJSONOperationForURL:@&quot;http://someurl&quot;]; [operation setCompletionBlockWithSuccess:^(NetworkOperation *theOperation, id *result) { [subscriber sendNext:result]; [subscriber sendCompleted]; } failure:^(NetworkOperation *theOperation, NSError *error) { [subscriber sendError:error]; }]; 我在这用一个具有成功和失败 block (伪造)的网络操作创建了一个信号. (如果我想让信号在被订阅时才让网络请求发生, 还可以用 RACSignal 的类方法 defer. )我在成功的 block 里使用提供的 subscriber 对象调用 sendNext: 和 sendCompleted: 方法, 或在失败的 block 中调用 sendError:. 现在我可以订阅这个信号并将在响应返回时接收到 json 值或是 error. 幸运的是, RAC 的创造者实际上使用它们自己的库来创建真的事物(捉摸一下), 所以对于我们在日常需要什么, 他们有很强烈的想法. 他们为我们提供了很多机制, 来从我们通常使用的现存的异步模式中拉取信号. 别忘了如果你有一个没有被某个内建信号覆盖到的异步任务, 你可以很容易地用 createSignal: 或类似方法来创建信号. 一个被提供的机制就是 RACObserve() 宏. (如果你不喜欢宏, 你可以简单地看看罩子下面并用稍微多些冗杂的描述. 这也非常好. 在我们得到 Swift 版本的替代之前, 这也有在 Swift 中使用 RAC 的解决方案. )这个宏是 RAC 中对 KVO 中那些悲惨的 API 的替代. 你只需要传入对象和你想观察的那个对象某属性的 keypath. 给出这些参数后, RACObserve 会创建一个信号, 一旦它有了订阅者, 它就立刻发送那个属性的当前值, 并在发送那个属性在这之后的任何变化. RACSignal *usernameValidSignal = RACObserve(self.viewModel, usernameIsValid); 这仅是提供用于创建信号的一个工具. 这里有几个立即可用的方式, 来从内置控制流机制中拉取信号: //signals.m RACSignal *controlUpdate = [myButton rac_signalForControlEvents:UIControlEventTouchUpInside]; // signals for UIControl events send the control event value (UITextField, UIButton, UISlider, etc) // subscribeNext:^(UIButton *button) { NSLog(@&quot;%@&quot;, button); // UIButton instance } RACSignal *textChange = [myTextField rac_textSignal]; // some special methods are provided for commonly needed control event values off certain controls // subscribeNext:^(UITextField *textfield) { NSLog(@&quot;%@&quot;, textfield.text); // &quot;Hello!&quot; } RACSignal *alertButtonClicked = [myAlertView rac_buttonClickedSignal]; // signals for some delegate methods send the delegate params as the value // e.g. UIAlertView, UIActionSheet, UIImagePickerControl, etc // (limited to methods that return void) // subscribeNext:^(NSNumber *buttonIndex) { NSLog(@&quot;%@&quot;, buttonIndex); // &quot;1&quot; } RACSignal *viewAppeared = [self rac_signalForSelector:@selector(viewDidAppear:)]; // signals for arbitrary selectors that return void, send the method params as the value // works for built in or your own methods // subscribeNext:^(NSNumber *animated) { NSLog(@&quot;viewDidAppear %@&quot;, animated); // &quot;viewDidAppear 1&quot; } 记住你也能轻松创建自己的信号, 包括替代那些没有内建支持的其他委托. 我们现在能够从所有这些不连贯的异步/控制流工具中拉取出信号并将他们合并, 试想想这该多酷!这些会成为我们之前看到的陈述性图表中的节点. 真是兴奋. 什么是订阅者?简言之, 订阅者就是一段代码, 它等待信号给它发送一些值, 然后订阅者就能处理这些值了. (它也可以作用于 “complete” 和 “error” 事件. ) 这有一个简单的订阅者, 是通过向信号的实例方法 subscribeNext 传入一个 block 来创建的. 我们在这通过 RACObserve() 宏创建信号来观察一个对象上属性的当前值, 并把它赋值给一个内部属性. - (void) viewDidLoad { // . . . // create and get a reference to the signal RACSignal *usernameValidSignal = RACObserve(self.viewModel, isUsernameValid); // update the local property when this value changes [usernameValidSignal subscribeNext: ^(NSNumber *isValidNumber) { self.usernameIsValid = isValidNumber. boolValue }]; } 注意 RAC 只处理对象, 而不处理像 BOOL 这样的原始值. 不过不用担心, RAC 通常会帮你这些转换. 幸运的是 RAC 的创造者也意识到这种绑定行为的普遍必要性, 所以他们提供了另一个宏 RAC(). 与 RACObserve() 相同, 你提供想要与即将到来的值绑定的对象和参数, 在其内部它所做的是创建一个订阅者并更新其属性的值. 我们的例子现在看起来像这样: - (void) viewDidLoad { //. . . RAC(self, usernameIsValid) = RACObserve(self.viewModel, isUsernameValid); } 考虑下我们的目标, 这么干有点傻啊. 我们不需要将信号发送的值存到属性中(这会创建状态), 我们真正要做的是用从那个值获取到信息来更新 UI. 转换数据流现在我们进入 RAC 为我们提供的用于转换数值流的方法. 我们将会利用 RACSignal 的实例方法 map. //transformingStreams.m - (void) viewDidLoad { //... RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, isUsernameValid); RAC(self.goButton, enabled) = usernameIsValidSignal; RAC(self.goButton, alpha) = [usernameIsValidSignal map:^id(NSNumber *usernameIsValid) { return usernameIsValid.boolValue ? @1.0 : @0.5; }]; } 这样现在我们将 view-model 上的 isUsernameValid 发生的变化直接绑定到 goButton 的 enabled 属性上. 酷吧?对 alpha 的绑定更酷, 因为我们正在使用 map 方法将值转换成与 alpha 属性相关的值. (注意在这里我们返回的是一个 NSNumber 对象而不是原始float值. 这基本上是唯一的污点: 你需要负责为 RAC 将原始值转化为对象, 因为它不能帮你导出来. 多个订阅者, 副作用, 昂贵的操作订阅信号链时要明白重要的一件事是每当一个新值通过信号链被发送出去时, 实际上会给每个订阅者都发送一次. 直到意识到这就我们而言是有意义的, 信号发出的值不存储在任何地方(除了 RAC 在内部实现中). 当信号需要发送一个新的值时, 它会遍历所有的订阅者并给每个订阅者发送那个值. (这是对信号链实际工作的简化说明, 但基本想法是对的) 这为什么重要?这意味着信号链某处存在的任何副作用, 任何影响应用世界的转变, 将会发生多次. 这对新接触 RAC 的用户来说是意想不到的. (这也违反了函数式构建的理念-数据输入, 数据输出). 一个做作的例子可能是: 信号链某处的信号在每次按钮被按下时更新 self 中的一个计数器属性. 如果信号链有多个订阅者, 计数器的增长将会比你想的还要多. 你需要努力从信号链中尽可能剔除副作用. 当副作用不可避免时, 你可以使用一些恰当的预防机制. 我将会在另一篇文章中探索. 除副作用之外, 你需要注意带有昂贵操作和可变数据的信号链. 网络请求就是一个三者兼得的例子: 网络请求影响了应用的网络层(副作用).网络请求为信号链引入了可变数据. (两个完全一样请求可能返回了不同的数据. )网络请求反应慢啊.例如, 你可能有个信号在每次按钮按下时发送一个值, 而你想将这个值转换成网络请求的结果. 如果有多个订阅者要这个处理信号链上返回的这个值, 你将发起多个网络请求. 网络请求明显是经常需要的. 正如你所期望, RAC 提供这些情况的解决方案, 也就是 RACCommand 和多点广播. 我将会在下一篇文章中更深入地分析. Tweetboat Plus既然简短的介绍(嗯哼)扯远了, 让我们着眼于如何用 ReactiveCocoa 将 view-model 与视图控制器连接起来. // // View Controller // - (void) viewDidLoad { [super viewDidLoad]; RAC(self.viewModel, username) = [myTextfield rac_textSignal]; RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, usernameValid); RAC(self.goButton, alpha) = [usernameIsValidSignal map: ^(NSNumber *valid) { return valid. boolValue ? @1 : @0. 5; }]; RAC(self.goButton, enabled) = usernameIsValidSignal; RAC(self.avatarImageView, image) = RACObserve(self.viewModel, userAvatarImage); RAC(self.userNameLabel, text) = RACObserve(self.viewModel, userFullName); @weakify(self); [[[RACSignal merge: @[RACObserve(self.viewModel, tweets), RACObserve(self.viewModel, allTweetsLoaded)]] bufferWithTime: 0 onScheduler: [RACScheduler mainThreadScheduler]] subscribeNext: ^(id value) { @strongify(self); [self.tableView reloadData]; }]; [[self.goButton rac_signalForControlEvents: UIControlEventTouchUpInside] subscribeNext: ^(id value) { @strongify(self); [self.viewModel getTweetsForCurrentUsername]; }]; } -(UITableViewCell*)tableView: (UITableView *)tableView cellForRowAtIndexPath: (NSIndexPath *)indexPath { // if table section is the tweets section if (indexPath. section == 0) { MYTwitterUserCell *cell = [self.tableView dequeueReusableCellWithIdentifier: @&quot;MYTwitterUserCell&quot; forIndexPath: indexPath]; // grab the cell view model from the vc view model and assign it cell.viewModel = self.viewModel. tweets[indexPath. row]; return cell; } else { // else if the section is our loading cell MYLoadingCell *cell = [self.tableView dequeueReusableCellWithIdentifier: @&quot;MYLoadingCell&quot; forIndexPath: indexPath]; [self.viewModel loadMoreTweets]; return cell; } } // // MYTwitterUserCell // // this could also be in cell init - (void) awakeFromNib { [super awakeFromNib]; RAC(self.avatarImageView, image) = RACObserve(self, viewModel. tweetAuthorAvatarImage); RAC(self.userNameLabel, text) = RACObserve(self, viewModel. tweetAuthorFullName); RAC(self.tweetTextLabel, text) = RACObserve(self, viewModel. tweetContent); } 让我们过一遍这个例子. RAC(self.viewModel, username) = [myTextfield rac_textSignal]; 在这我们用 RAC 库中的方法从 UITextField 拉取一个信号. 这行代码将 view-model 上的可读写属性 username 绑定到文本框上的用户输入的任何更新. RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, usernameValid); RAC(self.goButton, alpha) = [usernameIsValidSignal map: ^(NSNumber *valid) { return valid. boolValue ? @1 : @0. 5; }]; RAC(self.goButton, enabled) = usernameIsValidSignal; 在这我们用 RACObserve 方法在 view-model 的 usernameValid 属性上创建了一个信号 usernameIsValidSignal. 无论何时属性发生变化, 它将会沿着管道发送一个新的 @YES 或 @NO. 我们拿到那个值并将其绑定到 goButton 的两个属性上. 首先我们将 alpha 分别对应 YES 或 NO 更新到1或0. 5(记着在这必须返回 NSNumber). 然后我们直接将信号绑定到 enabled 属性, 因为 YES 和 NO 在这无需转换就能完美地运作. RAC(self.avatarImageView, image) = RACObserve(self.viewModel, userAvatarImage); RAC(self.userNameLabel, text) = RACObserve(self.viewModel, userFullName); 下面我们为表头的图像视图和用户标签创建绑定, 再次在 view-model 上对应的属性上用 RACObserve 宏创建信号. @weakify(self); [[[RACSignal merge: @[RACObserve(self.viewModel, tweets), RACObserve(self.viewModel, allTweetsLoaded)]] bufferWithTime: 0 onScheduler: [RACScheduler mainThreadScheduler]] subscribeNext: ^(id value) { @strongify(self); [self.tableView reloadData]; }]; 这货看上去有点诡异, 所以我们在这上多花点时间. 我们想在 view-model 上 tweets 数组或 allTweetsLoaded 属性发生变化时更新表格视图. (在这个例子中, 我们要用一个简单的方法来重新加载整张表. )所以我们将这两个属性被观察后创建的两个信号合并成一个更大的信号, 当两个属性中有一个发生变化, 这个信号就会发送值. (你一贯认为信号的值是同类型的, 不会像这个信号有一样混杂的值. 这很可能在 Swift 版本的 RAC 中强制要求, 但在这我们不关心发出的真实值, 我们只是用它来触发表格式图的重新加载. ) 那么这儿看起来最吓人的部分可能是信号链中的 bufferWithTime: onScheduler: 方法. 需要它来围绕 UIKit 中的一个问题进行变通. tweets 和 allTweetsLoaded 这两个属性我们都需要追踪, 万一 tweets 变化和 allTweetsLoaded 为否(不管怎样我们都得重新加载表格). 有时两个属性都将在同一准确的时间发生变化, 意味着合并后的大信号中的两个信号都会发送一个值, 那么 reloadData 方法将会在同一个运行循环中被调用两次. UIKit 不喜欢这样. bufferWithTime: 在给明的时间内抓取所有下一个到来的值, 当给定的时间过后将所有值合在一起发给订阅者. 通过传入0作为时间, bufferWithTime: 将会抓取那个合并信号在特定的运行循环中发出的全部值, 并将他们一起发送出去. (NSTimer 以同样的方式工作, 这不是巧合, 因为 bufferWithTime: 是用 NSTimer 构建的. )暂时不用担心 scheduler, 试把它想做指明这些值必须在主线程上被发送. 现在我们确保 reloadData 每次运行循环只被调用一次. 注意我在这用 @weakify/@strongify 宏切换 strong 和 weak. 这在创建所有这些 block 时非常重要. 在 RAC 的 block 中使用 self 时self 将会被捕获为强引用并得到保留环, 除非你尤其意识到要破除保留环 [[self.goButton rac_signalForControlEvents: UIControlEventTouchUpInside] subscribeNext: ^(id value) { @strongify(self); [self.viewModel getTweetsForCurrentUsername]; }]; 我将会在下一篇文章中在这里引入 RACCommand, 但目前我们只是当按钮被触碰时手动调用 view-model 的 getTweetsForCurrentUsername 方法. 我们已经搞定了 cellForRowAtIndexPath 的第一部分, 那么我在这将只说下 loading cell: MYLoadingCell *cell = [self.tableView dequeueReusableCellWithIdentifier: @&quot;MYLoadingCell&quot; forIndexPath: indexPath]; [self.viewModel loadMoreTweets]; return cell; 这是另一块我们以后将利用到 RACCommand 的地方, 但目前我们只是调用 view-model 的 loadMoreTweets 方法. 我们将只是信任如果 cell 显示或隐藏多次的话 view-model 会避免多次内部调用. - (void) awakeFromNib { [super awakeFromNib]; RAC(self.avatarImageView, image) = RACObserve(self, viewModel. tweetAuthorAvatarImage); RAC(self.userNameLabel, text) = RACObserve(self, viewModel. tweetAuthorFullName); RAC(self.tweetTextLabel, text) = RACObserve(self, viewModel. tweetContent); } 这段现在应该非常直接了, 除此之外我想指出一点. 我们正在将图片和文字绑定到 UI 上对应的属性, 但注意 viewModel 出现在 RACObserve 宏中逗号右边. 这些 cell 终将被重用, 新的 view-models 将会被赋值. 如果我们不将 viewModel 放在逗号右边, 那就会监听 viewModel 属性的变化然后每次都要重新设置绑定;如果放在逗号右边, RACObserve 将会为我们负责这些事儿. 因此我们只需要设定一次绑定并让 Reactive Cocoa 做剩余的部分. 这是在绑定表格 cell 时为了性能需要记住的好东西. 我在实践中即使是有很多表格 cell 依然没有出过问题. 福利-消除更多的状态有时候你可以在 view-model 中暴露 RACSignal 对象来替代像字符串和图像这样的属性, 这能在 view-model 上消除更多的状态. 然后视图控制器就不需要自己用 RACObserve 创建信号了, 并只是直接影响这些信号. 要意识到如果你的信号在被 UI 订阅/绑定到 UI 之前发出过一个值, 那么你将不会收到那个”初始”的值. 结论本文篇幅略长, 但别被吓着. 这还有好多没讲的, 而且是干货儿, 是舒展你大脑的好方法. 这毫无疑问是不同的编程风格. 花一会儿功夫停止机械地试图用命令式方案去解决问题. 即使你一开始不是经常用这种编程风格, 我认为这有助于理解和提醒我们有截然不同的途径来解决我们程序员的困惑. 下一次我将稍微深入 view-model 内部中本文没提到的内容, 并介绍下 RACCommand(希望篇幅能短很多). 然后我们将投入到一个真实案例中, 那是我的一个叫做Three Cents的 app 中的一个相当复杂的页面, 它混合了网络调用, CoreData, 多重 UI 状态, 等等! 拓展阅读","tags":[{"name":"MVVM  RAC","slug":"MVVM-RAC","permalink":"http://jokersnow.com/tags/MVVM-RAC/"}]},{"title":"发布博客中的小问题总结","date":"2017-06-29T08:40:34.000Z","path":"2017/06/29/发布博客中的小问题总结/","text":"1.在markdown 中插入图片链接不显示 正确的姿势是 感叹号! 中括号[] 左小括号（链接）右小括号 注：文字只用于说明 由于markdown会识别 所以只能文字描述 例如 2.博客的文章在列表中显示特别长，只需要在文章内容中想要截断的部分插入 左尖括号感叹号横线横线more横线横线右尖括号 注：文字只用于说明 由于markdown会识别 所以只能文字描述","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://jokersnow.com/tags/Markdown/"}]},{"title":"最快让你上手ReactiveCocoa之基础篇","date":"2017-06-29T07:56:25.000Z","path":"2017/06/29/最快让你上手ReactiveCocoa之基础篇/","text":"1.ReactiveCocoa简介 ReactiveCocoa（简称为RAC）,是由Github开源的一个应用于iOS和OS开发的新框架,Cocoa是苹果整套框架的简称，因此很多苹果框架喜欢以Cocoa结尾。2.ReactiveCocoa作用 在我们iOS开发过程中，当某些事件响应的时候，需要处理某些业务逻辑,这些事件都用不同的方式来处理。比如按钮的点击使用action，ScrollView滚动使用delegate，属性值改变使用KVO等系统提供的方式。其实这些事件，都可以通过RAC处理ReactiveCocoa为事件提供了很多处理方法，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要跳到对应的方法里。非常符合我们开发中高聚合，低耦合的思想。 3.编程思想 在开发中我们也不能太依赖于某个框架，否则这个框架不更新了，导致项目后期没办法维护，比如之前Facebook提供的Three20框架，在当时也是神器，但是后来不更新了，也就没什么人用了。因此我感觉学习一个框架，还是有必要了解它的编程思想。 先简单介绍下目前咱们已知的编程思想。 3.1 面向过程：处理事情以过程为核心，一步一步的实现。 3.2 面向对象：万物皆对象 3.3 链式编程思想：是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。a(1).b(2).c(3) 链式编程特点：方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值） 代表：masonry框架。 模仿masonry，写一个加法计算器，练习链式编程思想。3.3.1. 3.3.2. 3.3.3. 3.3.4. 3.3.5. 3.4 响应式编程思想：不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。 代表：KVO运用。3.5 函数式编程思想：是把操作尽量写成一系列嵌套的函数或者方法调用。 函数式编程特点：每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果） 代表：ReactiveCocoa。 用函数式编程实现，写一个加法计算器,并且加法计算器自带判断是否等于某个值. 3.5.1 3.5.2 4.ReactiveCocoa编程思想 ReactiveCocoa结合了几种编程风格： 函数式编程（Functional Programming） 响应式编程（Reactive Programming） 所以，你可能听说过ReactiveCocoa被描述为函数响应式编程（FRP）框架。 以后使用RAC解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。 5.如何导入ReactiveCocoa框架 通常都会使用CocoaPods（用于管理第三方框架的插件）帮助我们导入。 PS:CocoaPods教程 注意： podfile如果只描述pod ‘ReactiveCocoa’, ‘~&gt; 4.0.2-alpha-1’，会导入不成功。 5.1.1 5.1.2 报错提示信息 5.1.3 需要在podfile加上use_frameworks，重新pod install 才能导入成功。 6.ReactiveCocoa常见类。 学习框架首要之处:个人认为先要搞清楚框架中常用的类，在RAC中最核心的类RACSiganl,搞定这个类就能用ReactiveCocoa开发了。 6.1RACSiganl:信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。 注意： 信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。 默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。 如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。 RACSiganl简单使用: // RACSignal使用步骤： // 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe // 2.订阅信号,才会激活信号. - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock // 3.发送信号 - (void)sendNext:(id)value // RACSignal底层实现： // 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。 // 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock // 2.2 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。 // 2.1 subscribeNext内部会调用siganl的didSubscribe // 3.siganl的didSubscribe中调用[subscriber sendNext:@1]; // 3.1 sendNext底层其实就是执行subscriber的nextBlock // 1.创建信号 RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { // block调用时刻：每当有订阅者订阅信号，就会调用block。 // 2.发送信号 [subscriber sendNext:@1]; // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。 [subscriber sendCompleted]; return [RACDisposable disposableWithBlock:^{ // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。 // 执行完Block后，当前信号就不在被订阅了。 NSLog(@&quot;信号被销毁&quot;); }]; }]; // 3.订阅信号,才会激活信号. [siganl subscribeNext:^(id x) { // block调用时刻：每当有信号发出数据，就会调用block. NSLog(@&quot;接收到数据:%@&quot;,x); }]; 6.2 RACSubscriber:表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。 6.3 RACDisposable:用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。 使用场景:不想监听某个信号时，可以通过它主动取消订阅信号。6.4 RACSubject:RACSubject:信号提供者，自己可以充当信号，又能发送信号。 使用场景:通常用来代替代理，有了它，就不必要定义代理了。RACReplaySubject:重复提供信号类，RACSubject的子类。 RACReplaySubject与RACSubject区别: RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。 使用场景一:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。 使用场景二:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。 RACSubject和RACReplaySubject简单使用: // RACSubject使用步骤 // 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。 // 2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock // 3.发送信号 sendNext:(id)value // RACSubject:底层实现和RACSignal不一样。 // 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。 // 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。 // 1.创建信号 RACSubject *subject = [RACSubject subject]; // 2.订阅信号 [subject subscribeNext:^(id x) { // block调用时刻：当信号发出新值，就会调用. NSLog(@&quot;第一个订阅者%@&quot;,x); }]; [subject subscribeNext:^(id x) { // block调用时刻：当信号发出新值，就会调用. NSLog(@&quot;第二个订阅者%@&quot;,x); }]; // 3.发送信号 [subject sendNext:@&quot;1&quot;]; // RACReplaySubject使用步骤: // 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。 // 2.可以先订阅信号，也可以先发送信号。 // 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock // 2.2 发送信号 sendNext:(id)value // RACReplaySubject:底层实现和RACSubject不一样。 // 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。 // 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock // 如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。 // 也就是先保存值，在订阅值。 // 1.创建信号 RACReplaySubject *replaySubject = [RACReplaySubject subject]; // 2.发送信号 [replaySubject sendNext:@1]; [replaySubject sendNext:@2]; // 3.订阅信号 [replaySubject subscribeNext:^(id x) { NSLog(@&quot;第一个订阅者接收到的数据%@&quot;,x); }]; // 订阅信号 [replaySubject subscribeNext:^(id x) { NSLog(@&quot;第二个订阅者接收到的数据%@&quot;,x); }]; RACSubject替换代理 // 需求: // 1.给当前控制器添加一个按钮，modal到另一个控制器界面 // 2.另一个控制器view中有个按钮，点击按钮，通知当前控制器 步骤一：在第二个控制器.h，添加一个RACSubject代替代理。 @interface TwoViewController : UIViewController @property (nonatomic, strong) RACSubject *delegateSignal; @end 步骤二：监听第二个控制器按钮点击 @implementation TwoViewController - (IBAction)notice:(id)sender { // 通知第一个控制器，告诉它，按钮被点了 // 通知代理 // 判断代理信号是否有值 if (self.delegateSignal) { // 有值，才需要通知 [self.delegateSignal sendNext:nil]; } } @end 步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听. @implementation OneViewController - (IBAction)btnClick:(id)sender { // 创建第二个控制器 TwoViewController *twoVc = [[TwoViewController alloc] init]; // 设置代理信号 twoVc.delegateSignal = [RACSubject subject]; // 订阅代理信号 [twoVc.delegateSignal subscribeNext:^(id x) { NSLog(@&quot;点击了通知按钮&quot;); }]; // 跳转到第二个控制器 [self presentViewController:twoVc animated:YES completion:nil]; } @end 6.6RACTuple:元组类,类似NSArray,用来包装值. 6.7RACSequence:RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。 使用场景：1.字典转模型 RACSequence和RACTuple简单使用 // 1.遍历数组 NSArray *numbers = @[@1,@2,@3,@4]; // 这里其实是三步 // 第一步: 把数组转换成集合RACSequence numbers.rac_sequence // 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal // 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。 [numbers.rac_sequence.signal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }]; // 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象) NSDictionary *dict = @{@&quot;name&quot;:@&quot;xmg&quot;,@&quot;age&quot;:@18}; [dict.rac_sequence.signal subscribeNext:^(RACTuple *x) { // 解包元组，会把元组的值，按顺序给参数里面的变量赋值 RACTupleUnpack(NSString *key,NSString *value) = x; // 相当于以下写法 // NSString *key = x[0]; // NSString *value = x[1]; NSLog(@&quot;%@ %@&quot;,key,value); }]; // 3.字典转模型 // 3.1 OC写法 NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil]; NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath]; NSMutableArray *items = [NSMutableArray array]; for (NSDictionary *dict in dictArr) { FlagItem *item = [FlagItem flagWithDict:dict]; [items addObject:item]; } // 3.2 RAC写法 NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil]; NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath]; NSMutableArray *flags = [NSMutableArray array]; _flags = flags; // rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。 [dictArr.rac_sequence.signal subscribeNext:^(id x) { // 运用RAC遍历字典，x：字典 FlagItem *item = [FlagItem flagWithDict:x]; [flags addObject:item]; }]; NSLog(@&quot;%@&quot;, NSStringFromCGRect([UIScreen mainScreen].bounds)); // 3.3 RAC高级写法: NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil]; NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath]; // map:映射的意思，目的：把原始值value映射成一个新值 // array: 把集合转换成数组 // 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。 NSArray *flags = [[dictArr.rac_sequence map:^id(id value) { return [FlagItem flagWithDict:value]; }] array]; 6.8RACCommand:RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。 使用场景:监听按钮点击，网络请求 RACCommand简单使用 // 一、RACCommand使用步骤: // 1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock // 2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值 // 3.执行命令 - (RACSignal *)execute:(id)input // 二、RACCommand使用注意: // 1.signalBlock必须要返回一个信号，不能传nil. // 2.如果不想要传递信号，直接创建空的信号[RACSignal empty]; // 3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。 // 4.RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。 // 三、RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。 // 1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。 // 2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。 // 四、如何拿到RACCommand中返回信号发出的数据。 // 1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。 // 2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。 // 五、监听当前命令是否正在执行executing // 六、使用场景,监听按钮点击，网络请求 // 1.创建命令 RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) { NSLog(@&quot;执行命令&quot;); // 创建空信号,必须返回信号 // return [RACSignal empty]; // 2.创建信号,用来传递数据 return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { [subscriber sendNext:@&quot;请求数据&quot;]; // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。 [subscriber sendCompleted]; return nil; }]; }]; // 强引用命令，不要被销毁，否则接收不到数据 _conmmand = command; // 3.订阅RACCommand中的信号 [command.executionSignals subscribeNext:^(id x) { [x subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }]; }]; // RAC高级用法 // switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号 [command.executionSignals.switchToLatest subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }]; // 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。 [[command.executing skip:1] subscribeNext:^(id x) { if ([x boolValue] == YES) { // 正在执行 NSLog(@&quot;正在执行&quot;); }else{ // 执行完成 NSLog(@&quot;执行完成&quot;); } }]; // 5.执行命令 [self.conmmand execute:@1]; 6.9RACMulticastConnection:用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。 使用注意:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建. RACMulticastConnection简单使用: // RACMulticastConnection使用步骤: // 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe // 2.创建连接 RACMulticastConnection *connect = [signal publish]; // 3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock] // 4.连接 [connect connect] // RACMulticastConnection底层原理: // 1.创建connect，connect.sourceSignal -&gt; RACSignal(原始信号) connect.signal -&gt; RACSubject // 2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。 // 3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject // 3.1.订阅原始信号，就会调用原始信号中的didSubscribe // 3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext // 4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。 // 4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock // 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。 // 解决：使用RACMulticastConnection就能解决. // 1.创建请求信号 RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { NSLog(@&quot;发送请求&quot;); return nil; }]; // 2.订阅信号 [signal subscribeNext:^(id x) { NSLog(@&quot;接收数据&quot;); }]; // 2.订阅信号 [signal subscribeNext:^(id x) { NSLog(@&quot;接收数据&quot;); }]; // 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求 // RACMulticastConnection:解决重复请求问题 // 1.创建信号 RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { NSLog(@&quot;发送请求&quot;); [subscriber sendNext:@1]; return nil; }]; // 2.创建连接 RACMulticastConnection *connect = [signal publish]; // 3.订阅信号， // 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext: [connect.signal subscribeNext:^(id x) { NSLog(@&quot;订阅者一信号&quot;); }]; [connect.signal subscribeNext:^(id x) { NSLog(@&quot;订阅者二信号&quot;); }]; // 4.连接,激活信号 [connect connect]; 6.10 RACScheduler:RAC中的队列，用GCD封装的。 6.11 RACUnit :表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil. 6.12 RACEvent: 把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。 7.ReactiveCocoa开发中常见用法。 7.1 代替代理: rac_signalForSelector：用于替代代理。7.2 代替KVO : rac_valuesAndChangesForKeyPath：用于监听某个对象的属性改变。7.3 监听事件: rac_signalForControlEvents：用于监听某个事件。7.4 代替通知: rac_addObserverForName:用于监听某个通知。7.5 监听文本框文字改变: rac_textSignal:只要文本框发出改变就会发出这个信号。7.6 处理当界面有多次请求时，需要都获取到数据时，才能展示界面 rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。7.7 代码演示 // 1.代替代理 // 需求：自定义redView,监听红色view中按钮点击 // 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情 // rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。 // 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。 [[redV rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) { NSLog(@&quot;点击红色按钮&quot;); }]; // 2.KVO // 把监听redV的center属性改变转换成信号，只要值改变就会发送信号 // observer:可以传入nil [[redV rac_valuesAndChangesForKeyPath:@&quot;center&quot; options:NSKeyValueObservingOptionNew observer:nil] subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }]; // 3.监听事件 // 把按钮点击事件转换为信号，点击按钮，就会发送信号 [[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) { NSLog(@&quot;按钮被点击了&quot;); }]; // 4.代替通知 // 把监听到的通知转换信号 [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) { NSLog(@&quot;键盘弹出&quot;); }]; // 5.监听文本框的文字改变 [_textField.rac_textSignal subscribeNext:^(id x) { NSLog(@&quot;文字改变了%@&quot;,x); }]; // 6.处理多个请求，都返回结果的时候，统一做处理. RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { // 发送请求1 [subscriber sendNext:@&quot;发送请求1&quot;]; return nil; }]; RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { // 发送请求2 [subscriber sendNext:@&quot;发送请求2&quot;]; return nil; }]; // 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。 [self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]]; } // 更新UI - (void)updateUIWithR1:(id)data r2:(id)data1 { NSLog(@&quot;更新UI%@ %@&quot;,data,data1); } 8.ReactiveCocoa常见宏。 8.1 RAC(TARGET, [KEYPATH, [NIL_VALUE]]):用于给某个对象的某个属性绑定。 // 只要文本框文字改变，就会修改label的文字 RAC(self.labelView,text) = _textField.rac_textSignal; 8.2 RACObserve(self, name):监听某个对象的某个属性,返回的是信号。 [RACObserve(self.view, center) subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }]; 8.3 @weakify(Obj)和@strongify(Obj),一般两个都是配套使用,在主头文件(ReactiveCocoa.h)中并没有导入，需要自己手动导入，RACEXTScope.h才可以使用。但是每次导入都非常麻烦，只需要在主头文件自己导入就好了。 8.4 RACTuplePack：把数据包装成RACTuple（元组类） // 把参数中的数据包装成元组 RACTuple *tuple = RACTuplePack(@10,@20); 8.5 RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。 // 把参数中的数据包装成元组 RACTuple *tuple = RACTuplePack(@&quot;xmg&quot;,@20); // 解包元组，会把元组的值，按顺序给参数里面的变量赋值 // name = @&quot;xmg&quot; age = @20 RACTupleUnpack(NSString *name,NSNumber *age) = tuple;","tags":[{"name":"RAC","slug":"RAC","permalink":"http://jokersnow.com/tags/RAC/"}]},{"title":"Homebrew","date":"2017-06-29T07:46:52.000Z","path":"2017/06/29/Homebrew/","text":"这是我的第一个个人博客，从开始到现在断断续续创建了几个月，当然利用Hexo引擎创建博客很方便，因为我也是实在不知道该写些什么感言。 人生就像一场旅行，不必在乎目的地，在乎的是沿途的风景以及看风景的心情。 我的愿望是 世界和平 -copy by 薛之谦","tags":[{"name":"blog","slug":"blog","permalink":"http://jokersnow.com/tags/blog/"}]}]